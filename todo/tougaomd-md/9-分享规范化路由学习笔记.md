---
title: '分享规范化路由学习笔记'
sidebar_position: 9
---

一白  一枚 学习规范化路由当中自己踩的坑,给大家分享一下

持续更新

## `问题一,接收API参数和返回响应数据.`

以登录为例

在API apiv1/hello.go  里创建结构体

注: 这里定义的req和res参数属性  就是我们这个API请求当中的接受参数和响应参数!  让我们可以快速的准确的获得数据,反馈数据

LoginDoReq 和 LoginDoRes  两个结构体的实例会作为参数传入handler里对应函数!

**请求响应结构体**

```
type LoginDoReq struct {
	g.Meta   `path:"/login" method:"post" summary:"执行登录请求" tags:"登录"`
	Name     string `json:"name" in:"query" d:"admin" dc:"账号"`
	Password string `json:"password" in:"query" d:"123456"  dc:"密码(明文)"`
}
type LoginDoRes struct {
	g.Meta `mime:"json" example:"string"`
	Token string `json:"token" dc:"返回token"`
}

```

在internal/handler/hello.go 里处理请求代码

注:最后一定记得 return,返回的状态码和描述怎么自定义下面展开说明

```
func (h *hHello) Login(ctx context.Context,req *apiv1.LoginDoReq)(res *apiv1.LoginDoRes,err error)  {

	token := req.Name + req.Password
	g.Dump(token)

	res = &apiv1.LoginDoRes{
		Token: token,
	}
	return
}
```

最后记得在internal/cmd/cmd.go  里注册一下Login方法对应的接受者,类似路由注册-对象注册的方法

补充方法:(非必要不使用)

在一些特殊情况比如获取请求头当中的数据等等,规范化现阶段无法获取后期会支持获取请求头,可以使用以下方法

```
g.RequestFromCtx(ctx).GetMap()
g.RequestFromCtx(ctx).GetHeader()
```

```
等等方法具体自己查一下文档
还有就是响应数据怎么想之前对象注册和函数注册那样返回相应
```

```
g.RequestFromCtx(ctx).Response.WriteJson(g.Map{"token":"我是一个假的token"})
```

## 问题二:自定义响应状态码cod及描述msg

一句话 重写 `ghttp.MiddlewareHandlerResponse 中间件 自己写一个后置中间件代替这个中间件` `这个中间件如果不使用  会让规范化路由返回是空!  `

```
type DefaultHandlerResponse struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

// 中间件 相应中间件
func MiddlewareGuRes(r *ghttp.Request) {
	r.Middleware.Next()
	// 有自定义缓冲区内容，然后退出当前处理程序,不是很理解
	//https://goframe.org/pages/viewpage.action?pageId=1114281 有时间看着吧
	if r.Response.BufferLength() > 0 {
		return
	}
	//定义接受的相应结果及错误
	var (
		err         error
		res         interface{}
	)
	//返回相应对象  及 获取不了的错误结果
	res, err = r.GetHandlerResponse()
	if err != nil {
		code := gerror.Code(err)   // 还没理解  后续补充
		if code == gcode.CodeNil {
			code = gcode.CodeInternalError
		}
		r.Response.WriteJson(DefaultHandlerResponse{
			Code:    CodeInternalServerError.code, //服务器内部错误  想改成500自己来
			Message: fmt.Sprint(CodeInternalServerError.msg,"具体错误原因如下:",err.Error(),"分割线",code.Message()),
			Data:    nil,
		})
		return
	}
	//没有问题返回结果
	r.Response.WriteJson(DefaultHandlerResponse{
		Code:    CodeOK.code,//请求成功  想改成200自己来
		Message: CodeOK.msg,
		Data:    res,
	})
}
```