---
slug: '/quick/strict-router'
title: 'Using Strict Routing'
hide_title: true
sidebar_position: 5
keywords: [GoFrame, GoFrame framework, strict routing, route registration, data structure, route object management, Go language, web server, HTTP methods, route callbacks]
description: "Use strict routing in the GoFrame framework to simplify route registration, focusing on business logic. Standardize route registration by defining request and response data structures, and manage routes using an object-oriented approach to enhance code maintainability. Provides complete sample code and execution results to guide readers in applying it to real projects."
---

To simplify the route registration method and avoid some tedious parameter handling details, allowing developers to focus on the business logic itself, the `GoFrame` framework provides a standardized route registration method. We name this standardized route registration method **Strict Routing** to make it straightforward and intuitive.

## Data Structure Definition

In strict routing, we define a request data structure to receive parameters submitted by the client, and at the same time, we need to define a return object. The purpose is for future return parameter extensions and to standardize interface documentation generation.
```go 
type HelloReq struct {
    g.Meta `path:"/" method:"get"`
    Name   string `v:"required" dc:"Name"`
    Age    int    `v:"required" dc:"Age"`
}
type HelloRes struct {}
```
Brief introduction:
- In the request object, we have an additional reference to a `g.Meta` object with some struct tags. This object is **metadata object**, used to embed some defined tag information into the struct. For example, in this example:
  - `path`: Indicates the registered route address.
  - `method`: Indicates the bound `HTTP Method`.
- Two new tag names also appear in the properties:
  - `v`: Represents the validation rules, abbreviated from `valid`, used for automatic validation of the parameter. Here `v:"required"` indicates that this parameter is required. If the client does not pass this parameter, the server will fail the validation.
  - `dc`: Represents the parameter description, abbreviated from `description`, used to describe the meaning of the parameter.

:::info
The corresponding chapter in the development manual contains a detailed explanation of all tag information and the validation component. You only need to understand its role here without going into too much detail.
:::

## Route Object Management

To better manage route registration, especially in scenarios with many interfaces, manually configuring the mapping between routes and callback functions one by one would be too tedious. We encapsulate the route callback function through an object-oriented form to simplify our route management. We define a route object as follows:

```go
type Hello struct{}

func (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
    r := g.RequestFromCtx(ctx)
    r.Response.Writef(
        "Hello %s! Your Age is %d",
        req.Name,
        req.Age,
    )
    return
}
```

- We defined a `Hello` object, which is used to encapsulate route callback functions. All defined public methods will be registered as route callback functions.
- You can see the callback function of the `Say` method of the route object in a way that is more in line with the business logic function definition style compared to the `func(*ghttp.Request)` callback function definition style.
- In the route callback method `Say`, we use the `g.RequestFromCtx` method to obtain the original `*ghttp.Request` request object from `ctx` for customizing return content data.

## Complete Example Code

We adapt our previous `Web Server` program as follows:
```go title="main.go"
package main

import (
    "context"

    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
)

type HelloReq struct {
    g.Meta `path:"/" method:"get"`
    Name   string `v:"required" dc:"Name"`
    Age    int    `v:"required" dc:"Age"`
}
type HelloRes struct{}

type Hello struct{}

func (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
    r := g.RequestFromCtx(ctx)
    r.Response.Writef(
        "Hello %s! Your Age is %d",
        req.Name,
        req.Age,
    )
    return
}

func main() {
    s := g.Server()
    s.Group("/", func(group *ghttp.RouterGroup) {
        group.Bind(
            new(Hello),
        )
    })
    s.SetPort(8000)
    s.Run()
}
```
In this example:
- A set of routes is registered using the `s.Group` grouping routing method, and all routes registered in its callback method will have the group route prefix `/`.
- The `group.Bind` method is used to register the route object. This method will traverse all public methods of the route object, read the input and output struct definitions of the methods, and execute route registration.

## Execution Result

After running, we visit http://127.0.0.1:8000/?name=john&age=18 and see that the page output is as expected.

![img.png](img.png)

We try an incorrect parameter request http://127.0.0.1:8000/ but find that the page does not output any results. **This is because the parameter validation failed and did not enter our route callback function, but was directly returned by the `Server`.**

## Learning Summary

In this chapter, we learned the strict route registration method, but we still lack control over the handling of return results, especially after errors occur. 

So, how should we capture validation errors and customize return data? We will introduce this further in the next chapter.