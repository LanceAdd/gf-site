---
slug: '/quick/request-struct'
title: 'Parameters Structure'
hide_title: true
sidebar_position: 4
keywords: [GoFrame, GoFrame Framework, Request Data Structure, Structured Request, Parameter Mapping, Data Validation, Web Server, Request Object, Hardcoding Parameter Names, API Optimization]
description: "Resolving the hardcoding problem of parameter names through data structuring, this introduces how to define request objects to receive client parameters, achieving parameter mapping and validation through the GoFrame framework to improve code maintainability. Additionally, the example program demonstrates methods to avoid redundant validation logic and explores more concise solutions."
---

In this example, we attempt to resolve the issue of hardcoding parameter names from the previous chapter by means of data structuring.

## Request Object

We define a data structure to receive the parameters submitted by the client:
```go 
type HelloReq struct {
    Name string // Name
    Age  int    // Age
}
```
Great, it looks like we can annotate the parameters and determine their types, eliminating the need for hardcoding parameter names.

## Sample Code

We adjust our previous `Web Server` program as follows:
```go title="main.go"
package main

import (
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
)

type HelloReq struct {
    Name string // Name
    Age  int    // Age
}

func main() {
    s := g.Server()
    s.BindHandler("/", func(r *ghttp.Request) {
        var req HelloReq
        if err := r.Parse(&req); err != nil {
            r.Response.Write(err.Error())
            return
        }
        if req.Name == "" {
            r.Response.Write("name should not be empty")
            return
        }
        if req.Age <= 0 {
            r.Response.Write("invalid age value")
            return
        }
        r.Response.Writef(
            "Hello %s! Your Age is %d",
            req.Name,
            req.Age,
        )
    })
    s.SetPort(8000)
    s.Run()
}
```
In this example:
- We use the `r.Parse` method to map request parameters onto a request object, allowing us to use parameters in an object-oriented manner. The `r.Parse` method automatically parses client-submitted parameters and assigns them to the specified object. There is a fixed name mapping logic internally, which you will learn in detail in the type conversion component of the development manual, and it is not elaborated on here.
- Additionally, we have added validation logic in this example to ensure that the `Name` and `Age` parameters cannot be empty.

## Execution Result

After running it, when we visit http://127.0.0.1:8000/?name=john&age=18, we can see that the page output matches expectations.

![img.png](img.png)

Let's try an erroneous parameter request at http://127.0.0.1:8000/, and we can see that parameters are validated as expected, with the page output also matching expectations.

![img_2.png](img_2.png)

## Learning Summary

In this chapter, we learned to avoid the problem of hardcoding parameter names by using structured request objects, allowing for better maintenance of parameter names, descriptions, and type definitions.

However, there are still areas for improvement in this sample code:
- The `r.Parse` operation is business-independent and should be handled separately from business logic.
- If there are many APIs, performing `r.Parse` in all of them becomes cumbersome.
- Regarding data validation, if there are many API parameters, performing numerous `if` data validation operations becomes overly cumbersome.

Is there a better way to simplify and resolve these issues? The answer is yes, and we will attempt to address this in the next chapter.