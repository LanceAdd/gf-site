---
slug: '/quick/middleware'
title: 'Introduction to Middleware'
hide_title: true
sidebar_position: 6
keywords: [GoFrame, Middleware, Web Server, ErrorHandler, Request Interception, Pre-middleware, Post-middleware, Custom Error Handling, GoFrame Framework, Request Flow Control]
description: "Use middleware in the GoFrame framework to intercept requests and return results, and implement custom processing logic through pre and post middleware. The example code demonstrates how to define an error handling middleware and bind it to a route. Middleware makes request error handling and output format unification flexible and powerful."
---

To address the question left over from the previous chapter: how to capture the returned error object and perform custom error handling. In this chapter, we will briefly introduce the middleware feature of the `Web Server` and then answer this question.

## Introduction to Middleware

Middleware is an interceptor design that can intercept requests and return results in a `Web Server`, and perform custom processing logic before and after them.

The definition of middleware is the same as a normal route callback function, but you can use the `Middleware` attribute object in the `Request` parameter to control the request flow.

There are two types of middleware: **Pre-middleware** and **Post-middleware**. Pre-middleware is called before the route service function, post-middleware is called after it.

```go
func Middleware(r *ghttp.Request) {
    // Pre-middleware processing logic
    r.Middleware.Next()
    // Post-middleware processing logic
}
```

After executing the processing logic in the middleware, the `r.Middleware.Next()` method is used to further execute the next process; if you exit directly without calling the `r.Middleware.Next()` method at this point, the subsequent execution process will be exited (for example, it can be used for request authentication processing).

## Using Middleware

We use middleware to make a simple modification to the program from the previous chapter, as follows:

```go title="main.go"
package main

import (
    "context"

    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
)

type HelloReq struct {
    g.Meta `path:"/" method:"get"`
    Name   string `v:"required" dc:"Name"`
    Age    int    `v:"required" dc:"Age"`
}
type HelloRes struct{}

type Hello struct{}

func (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
    r := g.RequestFromCtx(ctx)
    r.Response.Writef(
        "Hello %s! Your Age is %d",
        req.Name,
        req.Age,
    )
    return
}

func ErrorHandler(r *ghttp.Request) {
    // Execute the route callback function
    r.Middleware.Next()
    // Check if an error has occurred
    if err := r.GetError(); err != nil {
        r.Response.Write("error occurs: ", err.Error())
        return
    }
}

func main() {
    s := g.Server()
    s.Group("/", func(group *ghttp.RouterGroup) {
        group.Middleware(ErrorHandler)
        group.Bind(
            new(Hello),
        )
    })
    s.SetPort(8000)
    s.Run()
}
```

- We have defined an error-handling middleware `ErrorHandler`. In this middleware, we first execute the route function flow through `r.Middleware.Next()`, and then obtain whether an error has occurred in the route callback function through `r.GetError()`. If an error occurs, the error message is directly displayed.
- In the route registration, we bind the error handling middleware to all registered routes under this route group through `group.Middleware(ErrorHandler)`.

## Execution Result

After running, the terminal outputs:

```text
2024-11-06 22:30:06.927 [INFO] pid[35434]: http server started listening on [:8000]
2024-11-06 22:30:06.927 [INFO] {905637567a67051830833b2189796dda} openapi specification is disabled

  ADDRESS | METHOD | ROUTE |      HANDLER      |    MIDDLEWARE      
----------|--------|-------|-------------------|--------------------
  :8000   | GET    | /     | main.(*Hello).Say | main.ErrorHandler  
----------|--------|-------|-------------------|--------------------
```

The `MIDDLEWARE` section here has an additional `main.ErrorHandler` method, indicating the name of the middleware bound to this route.

We access http://127.0.0.1:8000/?name=john&age=18 and can see that the page output matches the expectation.

![img.png](img.png)

We try an incorrect parameter request http://127.0.0.1:8000/ and can see that the page output also matches the expectation.

![img_4.png](img_4.png)

## Learning Summary

We used middleware to perform custom handling of request errors and capture validation errors to return custom error messages. As you can see, the functionality of middleware is very flexible and powerful, and of course not limited to handling small scenarios like validation errors.

Imagine, if there are many interfaces in our project, and the output formats of these interfaces are usually fixed, such as all in `json` format. Can we unify the return data structure directly through middleware? The answer is, of course, yes, which we will introduce in the next chapter.