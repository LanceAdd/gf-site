---
slug: '/quick/common-response'
title: 'Response Structure'
hide_title: true
sidebar_position: 7
keywords: [GoFrame Framework, Unified Response Structure, JSON Format, API Data Structure, Route Callback Function, Middleware Definition, Execution Result, Error Handling, Example Code, API Documentation Generation]
description: "Use the GoFrame framework to unify API response structures to return data in JSON format, define API data structures and route callback functions, handle execution results using middleware, and provide complete example code. By applying these methods, you can achieve a unified data format encapsulation in business projects, simplifying the API documentation generation and maintenance process."
---

In this chapter, we will use a fixed data format to return results, whether the route function executes successfully or fails, we return the result to the caller in `json` format.

## Return Format Definition

We define a unified data structure:
```go
type Response struct {
    Message string      `json:"message" dc:"Message prompt"`
    Data    interface{} `json:"data"    dc:"Execution result"`
}
```
Since we need to return data in `json` format, we add the `json` tag to each field.

## API Data Structure
```go
type HelloReq struct {
    g.Meta `path:"/" method:"get"`
    Name   string `v:"required" json:"name" dc:"Name"`
    Age    int    `v:"required" json:"age"  dc:"Age"`
}
type HelloRes struct {
    Content string `json:"content" dc:"Return result"`
}
```
- We added a `Content` attribute to `HelloRes` for returning specific data via the route function.
- Since data needs to be returned in `json` format, all attribute fields are added with the `json` tag.

## Route Callback Function
```go
type Hello struct{}

func (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
    res = &HelloRes{
        Content: fmt.Sprintf(
            "Hello %s! Your Age is %d",
            req.Name,
            req.Age,
        ),
    }
    return
}
```
Here, we return the execution result using the `HelloRes` return data structure, instead of retrieving and writing the result directly through `g.RequestFromCtx(ctx)` as in previous examples.

## Middleware Definition

```go
func Middleware(r *ghttp.Request) {
    r.Middleware.Next()

    var (
        msg string
        res = r.GetHandlerResponse()
        err = r.GetError()
    )
    if err != nil {
        msg = err.Error()
    } else {
        msg = "OK"
    }
    r.Response.WriteJson(Response{
        Message: msg,
        Data:    res,
    })
}
```
In this middleware:
- The method `r.GetHandlerResponse()` retrieves the execution result of the route callback function, which is the first result parameter `*HelloRes` returned by the route callback function.
- The method `r.GetError()` retrieves the execution state of the route callback function, which is the second result parameter `error` returned by the route callback function. If this result is not `nil`, it indicates an error occurred during the execution of the callback function.
- The method `r.Response.WriteJson` integrates the result into the unified return data structure `Response` and encodes it in `json` format to return to the caller.

## Complete Example Code

```go title="main.go"
package main

import (
    "context"
    "fmt"

    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
)

type Response struct {
    Message string      `json:"message" dc:"Message prompt"`
    Data    interface{} `json:"data"    dc:"Execution result"`
}

type HelloReq struct {
    g.Meta `path:"/" method:"get"`
    Name   string `v:"required" json:"name" dc:"Name"`
    Age    int    `v:"required" json:"age"  dc:"Age"`
}
type HelloRes struct {
    Content string `json:"content" dc:"Return result"`
}

type Hello struct{}

func (Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
    res = &HelloRes{
        Content: fmt.Sprintf(
            "Hello %s! Your Age is %d",
            req.Name,
            req.Age,
        ),
    }
    return
}

func Middleware(r *ghttp.Request) {
    r.Middleware.Next()

    var (
        msg string
        res = r.GetHandlerResponse()
        err = r.GetError()
    )
    if err != nil {
        msg = err.Error()
    } else {
        msg = "OK"
    }
    r.Response.WriteJson(Response{
        Message: msg,
        Data:    res,
    })
}

func main() {
    s := g.Server()
    s.Group("/", func(group *ghttp.RouterGroup) {
        group.Middleware(Middleware)
        group.Bind(
            new(Hello),
        )
    })
    s.SetPort(8000)
    s.Run()
}
```
All code in the example has already been introduced, and we can run it directly.

## Execution Result

After running, we visit http://127.0.0.1:8000/?name=john&age=18 and see that the page output matches the expectation.

![img_3.png](img_3.png)

We try an incorrect parameter request http://127.0.0.1:8000/ and see that the page output still matches the expectation.

![img_5.png](img_5.png)

## Learning Summary

In this chapter, we learned how to use the common `json` format to unify the data format encapsulation of APIs, which is very necessary in large business projects with hundreds of APIs.

As you can see, we have structured the parameters completely, with detailed input and output parameter descriptions, type definitions, and even data validation rules. Could we automate the generation of API documentation based on this information? The answer is yes, and we will introduce this in the next chapter.