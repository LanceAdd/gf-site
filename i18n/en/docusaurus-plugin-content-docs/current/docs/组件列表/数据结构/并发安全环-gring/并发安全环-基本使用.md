---
slug: '/docs/components/container-gring-example'
title: 'Concurrency Safe Ring - Basic Usage'
sidebar_position: 0
hide_title: true
keywords: [GoFrame,Concurrency Safe,Ring Data Structure,Josephus Problem,GoFrame Framework,Non-Concurrency Safe,Programming Design,Ring Buffer,Infinite Loop,Counting Algorithm]
description: "Use the gring package in the GoFrame framework to simulate the Josephus problem, which is a famous mathematical and programming design problem. Use circular data structures to manage the survival status of players and demonstrate the process of number-counting elimination. The sample code shows in detail how to implement a concurrent and non-concurrent safe ring buffer mechanism in a Go environment, providing a foundation for solving similar problems."
---

### Josephus Problem

We use `ring` to simulate the [Josephus Problem](https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3857719):

> The famous Jewish historian Josephus once had the following story: After the Romans occupied Jotapata, 39 Jews, along with Josephus and his friend, hid in a cave. The 39 Jews decided they would rather die than be captured by the enemy, so they decided on a method of suicide. The 41 people formed a circle and started counting from the first person. Every third person had to commit suicide, and then the next person started counting again until everyone was dead. However, Josephus and his friend did not want to comply. They started with one person, skipped k-2 people (since the first person was already skipped), and killed the k-th person. Then, they skipped k-1 people and killed the k-th person. This process continued around the circle until only one person was left, who could continue living. The problem is, given n and k, where to stand at the beginning to avoid being executed?

The following example is for a non-concurrent safe scenario.

```go
package main

import (
    "fmt"
    "github.com/gogf/gf/v2/container/gring"
)

type Player struct {
    position int  // Position
    alive    bool // Whether alive
}

const (
    playerCount = 41  // Number of players
    startPos    = 1   // Starting position for counting
)

var (
    deadline = 3
)

func main() {
    r := gring.New(playerCount)

    // Set initial values for all players
    for i := 1; i <= playerCount; i++ {
        r.Put(&Player{i, true})
    }

    // If the starting position is not 1, then set the starting position
    if startPos > 1 {
        r.Move(startPos - 1)
    }

    counter   := 1  // Counting starts from 1, since the loop below starts counting from the second
    deadCount := 0  // Number of dead players, initial value is 0

    // Loop continues until all players are dead
    for deadCount < playerCount {
        // Move to the next person
        r.Next()

        // If the person is alive, counting continues
        if r.Val().(*Player).alive {
            counter++
        }

        // If the count reaches the deadline, this person is eliminated
        if counter == deadline {
            r.Val().(*Player).alive = false
            fmt.Printf("Player %d died!\n", r.Val().(*Player).position)
            deadCount++
            counter = 0
        }
    }
}
```

Upon execution, the output is:

```
Player 3 died!
Player 6 died!
Player 9 died!
Player 12 died!
Player 15 died!
Player 18 died!
Player 21 died!
Player 24 died!
Player 27 died!
Player 30 died!
Player 33 died!
Player 36 died!
Player 39 died!
Player 1 died!
Player 5 died!
Player 10 died!
Player 14 died!
Player 19 died!
Player 23 died!
Player 28 died!
Player 32 died!
Player 37 died!
Player 41 died!
Player 7 died!
Player 13 died!
Player 20 died!
Player 26 died!
Player 34 died!
Player 40 died!
Player 8 died!
Player 17 died!
Player 29 died!
Player 38 died!
Player 11 died!
Player 25 died!
Player 2 died!
Player 22 died!
Player 4 died!
Player 35 died!
Player 16 died!
Player 31 died!
```

It can be seen that `16` and `31` are the last two to be eliminated, so Josephus arranged his friend and himself in the `16th` and `31st` positions to be safe.