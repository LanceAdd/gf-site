---
slug: '/docs/web/router-pattern'
title: 'Route Management - Routing Rules'
sidebar_position: 0
hide_title: true
keywords: [GoFrame,GoFrame Framework,Route Management,Routing Rules,Naming Matching Rules,Fuzzy Matching Rules,Field Matching Rules,Route Priority,Dynamic Routing,Routing Features]
description: "The powerful routing capabilities and optimization features in the GoFrame framework, including various routing rules such as naming matching, fuzzy matching, and field matching. Illustrated with example code to demonstrate how to use these rules to manage and match different URLs. Additionally, a detailed explanation of how to effectively control routing priority by combining precise matching rules with dynamic matching rules."
---

The `GoFrame` framework has its own extremely powerful routing functionality, providing better routing features than any similar framework, supporting popular naming matching rules, fuzzy matching rules, and field matching rules, while offering an excellent priority management mechanism.

## An Example

Before diving into the core content of this chapter, let's first look at a simple example of using dynamic routing:

```go
package main

import (
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/frame/g"
)

func main() {
    s := g.Server()
    s.BindHandler("/:name", func(r *ghttp.Request){
       r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/:name/update", func(r *ghttp.Request){
        r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/:name/:action", func(r *ghttp.Request){
        r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/:name/*any", func(r *ghttp.Request){
       r.Response.Writeln(r.Router.Uri)
    })
    s.BindHandler("/user/list/{field}.html", func(r *ghttp.Request){
        r.Response.Writeln(r.Router.Uri)
    })
    s.SetPort(8199)
    s.Run()
}
```

In the above example, the `goframe` framework supports three types of fuzzy matching routing rules, where `:name`, `*any`, and `{field}` represent **naming matching rules**, **fuzzy matching rules**, and **field matching rules** respectively. Different rules use the `/` symbol to divide levels, and routing retrieval uses a **depth-first algorithm**, meaning that rules with deeper levels will have higher priority. Running the above example, we can see the effect by accessing several URLs:

```html
URL                                         Result
http://127.0.0.1:8199/user/list/2.html      /user/list/{field}.html
http://127.0.0.1:8199/user/update           /:name/update
http://127.0.0.1:8199/user/info             /:name/:action
http://127.0.0.1:8199/user                  /:name/*any
```

In this example, we can also see that due to priority restrictions, the routing rule `/:name` will be overridden by the `/:name/*any` rule, making it unmatchable. Therefore, when assigning routing rules, it is essential to plan and manage them uniformly to avoid similar situations.

## Registration Rules

### Route Registration Parameters

The **most basic** route binding method is the `BindHandler` method. Let's look at the prototype of the `BindHandler`, which we have been using so far:

```go
func (s *Server) BindHandler(pattern string, handler interface{})
```

#### `pattern` Parameter

The `pattern` is a route registration rule string, which is also used in other route registration methods. The parameter format is as follows:

```html
[HTTPMethod:]Routing Rule[@Domain]
```

Where `HTTPMethod` (`GET/PUT/POST/DELETE/PATCH/HEAD/CONNECT/OPTIONS/TRACE`) and `@Domain` are **optional parameters**, in most scenarios, specifying the routing rule parameter is sufficient. `BindHandler` will automatically bind to **all** request methods. If `HTTPMethod` is specified, the routing rule will only be effective for that request method. `@Domain` can specify the effective domain name, so the routing rule will only be effective under that domain.
:::tip
`BindHandler` is the most native route registration method. In most scenarios, we usually use **group routing** to manage routes, which will be introduced in subsequent chapters: [Route Registration - Group Routing](Route Management-Route Registration/Route Registration-Group Routing.md).
:::
#### `handler` Parameter

The `handler` parameter is typically used to specify routing functions. In our most basic examples, we use functions to register routes. A routing function needs to meet the following definition, i.e., it can receive the request object `ghttp.Request`:

```go
func(r *ghttp.Request) {
    // ...
}
```

Let's look at an example:

```go
package main

import (
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/frame/g"
)

func main() {
    s := g.Server()
    // This route rule will only be effective under GET requests
    s.BindHandler("GET:/{table}/list/{page}.html", func(r *ghttp.Request){
        r.Response.WriteJson(r.Router)
    })
    // This route rule will only be effective under GET requests and localhost domain
    s.BindHandler("GET:/order/info/{order_id}@localhost", func(r *ghttp.Request){
        r.Response.WriteJson(r.Router)
    })
    // This route rule will only be effective under DELETE requests
    s.BindHandler("DELETE:/comment/{id}", func(r *ghttp.Request){
        r.Response.WriteJson(r.Router)
    })
    s.SetPort(8199)
    s.Run()
}
```

The returned parameter `r.Router` is the matching route rule information. When accessing this method, the server will output the current matching route rule information. We then test this in a terminal using the `curl` command:

```bash
$ curl -XGET http://127.0.0.1:8199/order/list/1.html
{"Domain":"default","Method":"GET","Priority":3,"Uri":"/{table}/list/{page}.html"}

$ curl -XGET http://127.0.0.1:8199/order/info/1
Not Found

$ curl -XGET http://localhost:8199/order/info/1
{"Domain":"localhost","Method":"GET","Priority":3,"Uri":"/order/info/{order_id}"}

$ curl -XDELETE http://127.0.0.1:8199/comment/1000
{"Domain":"default","Method":"DELETE","Priority":2,"Uri":"/comment/{id}"}

$ curl -XGET http://127.0.0.1:8199/comment/1000
Not Found
```

### Precise Matching Rules

Precise matching rules are rules **without any dynamic rules**, such as: `user`, `order`, `info`, etc., which are **specific names**. In most scenarios, precise matching rules will be used together with dynamic rules for route registration (e.g., `/:name/list`, where level 1 `:name` is the naming matching rule, and level 2 `list` is the precise matching rule).

### Dynamic Routing Rules

Dynamic routing rules are divided into three types: **naming matching rules**, **fuzzy matching rules**, and **field matching rules**. The underlying data structure of dynamic routing is a `routing tree` constructed by a level `hash table` and a `doubly linked list`. The level hash table facilitates efficient level matching of `URI`; the data linked list is used for priority control, with routing rules at the same level sorted by priority, and rules with higher priority placed at the head of the list. The underlying routing rules and request `URI` matching calculations use regular expressions and make full use of caching mechanisms, achieving high execution efficiency.

All matched parameters will be passed to the business layer as `Router` parameters, which can be obtained through the following method of the `ghttp.Request` object:

```go
func (r *Request) GetRouter(key string, def ...interface{}) *gvar.Var
```

You can also use the `ghttp.Request.Get` method to get the matched routing parameters.

#### Naming Matching Rules

Using the `:name` method for matching (`name` is a custom matching name), it performs naming matching on parameters of a specified level in the `URI` (similar to regular `([^/]+)`, this `URI` level must have a value), and the corresponding matching parameters will be parsed as `Router` parameters and passed to the registered service interface.

Matching Example 1:

```html
rule: /user/:user

/user/john                match
/user/you                 match
/user/john/profile        no match
/user/                    no match
```

Matching Example 2:

```html
rule: /:name/action

/john/name                no match
/john/action              match
/smith/info               no match
/smith/info/age           no match
/smith/action             match
```

Matching Example 3:

```html
rule: /:name/:action

/john/name                match
/john/info                match
/smith/info               match
/smith/info/age           no match
/smith/action/del         no match
```

#### Fuzzy Matching Rules

Using the `*any` method for matching (`any` is a custom matching name), it performs fuzzy matching on parameters after a specified position in the `URI` (similar to regular `.(.*)`, this `URI` level can be empty) and parses the matching parameters as `Router` parameters and passes them to the registered service interface.

Matching Example 1:

```html
rule: /src/*path

/src/                     match
/src/somefile.go          match
/src/subdir/somefile.go   match
/user/                    no match
/user/john                no match
```

Matching Example 2:

```html
rule: /src/*path/:action

/src/                     no match
/src/somefile.go          no match
/src/somefile.go/del      match
/src/subdir/file.go/del   match
```

Matching Example 3:

```html
rule: /src/*path/show

/src/                     no match
/src/somefile.go          no match
/src/somefile.go/del      no match
/src/somefile.go/show     match
/src/subdir/file.go/show  match
/src/show                 match
```

#### Field Matching Rules

Using the `{field}` method for matching (`field` is a custom matching name), it performs capturing matches on parameters at **any position** in the `URI` (similar to regular `([\w\.\-]+)`, this `URI` level must have a value and allows multiple field matches at the same level), and parses the matching parameters as `Router` parameters to be passed to the registered service interface.

Matching Example 1:

```html
rule: /order/list/{page}.php

/order/list/1.php          match
/order/list/666.php        match
/order/list/2.php5         no match
/order/list/1              no match
/order/list                no match
```

Matching Example 2:

```html
rule: /db-{table}/{id}

/db-user/1                     match
/db-user/2                     match
/db/user/1                     no match
/db-order/100                  match
/database-order/100            no match
```

Matching Example 3:

```html
rule: /{obj}-{act}/*param

/user-delete/10                match
/order-update/20               match
/log-list                      match
/log/list/1                    no match
/comment/delete/10             no match
```

### Dynamic Routing Example

```go
package main

import (
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/frame/g"
)

func main() {
    s := g.Server()
    // A simple paging routing example
    s.BindHandler("/user/list/{page}.html", func(r *ghttp.Request){
        r.Response.Writeln(r.Get("page"))
    })
    // Mixed use of {xxx} rule and :xxx rule
    s.BindHandler("/{object}/:attr/{act}.php", func(r *ghttp.Request){
        r.Response.Writeln(r.Get("object"))
        r.Response.Writeln(r.Get("attr"))
        r.Response.Writeln(r.Get("act"))
    })
    // Mix multiple fuzzy matching rules
    s.BindHandler("/{class}-{course}/:name/*act", func(r *ghttp.Request){
        r.Response.Writeln(r.Get("class"))
        r.Response.Writeln(r.Get("course"))
        r.Response.Writeln(r.Get("name"))
        r.Response.Writeln(r.Get("act"))
    })
    s.SetPort(8199)
    s.Run()
}
```

After executing, we can test through the `curl` command or by accessing via a browser, with the following test results:

```bash
$ curl -XGET http://127.0.0.1:8199/user/list/1.html
1

$ curl -XGET http://127.0.0.1:8199/user/info/save.php
user
info
save

$ curl -XGET http://127.0.0.1:8199/class3-math/john/score
class3
math
john
score
```

## Priority Control

Priority control follows the **depth-first strategy**, with a brief calculation strategy:

1. **The deeper the level of the rule, the higher the priority**;
2. **At the same level, precise matching takes precedence over fuzzy matching**;
3. **Priority for fuzzy matching at the same level: Field Matching > Naming Matching > Fuzzy Matching**;

Let's look at some examples (the rule on the left has a higher priority than the rule on the right):

```html
/:name                   >            /*any
/user/name               >            /user/:action
/:name/info              >            /:name/:action
/:name/:action           >            /:name/*action
/:name/{action}          >            /:name/:action
/src/path/del            >            /src/path
/src/path/del            >            /src/path/:action
/src/path/*any           >            /src/path
```