---
slug: '/docs/web/request-struct-converting'
title: 'Request Input - Object Handling'
sidebar_position: 1
hide_title: true
keywords: [Object conversion, Parameter mapping, GoFrame framework, Request parsing, Struct conversion, Custom mapping, Data validation, Route registration, JSON response, Golang]
description: "This document provides a detailed overview of how to handle object conversion for request input when using the GoFrame framework. By defining inputs and outputs as struct objects, it facilitates structured parameter maintenance. It introduces the default and custom parameter mapping rules and how to conveniently perform object conversion and data validation using the Parse method of the Request object."
---

## Object Conversion

Object conversion is very common in request processing. We recommend defining inputs and outputs as `struct` objects to facilitate structured parameter input and output maintenance. The `GoFrame` framework supports very convenient object conversion, allowing client-submitted parameters such as `Query` parameters, form parameters, content parameters, `JSON/XML`, etc., to be easily converted to designated `struct` objects. It also supports maintaining the mapping relationship between submitted parameters and `struct` attributes.

The object conversion method uses the `Parse` method or `Get*Struct` methods of the `Request` object. For specific method definitions, please refer to the API documentation: [https://pkg.go.dev/github.com/gogf/gf/v2/net/ghttp#Request](https://pkg.go.dev/github.com/gogf/gf/v2/net/ghttp#Request)

## Parameter Mapping

### Default Rules

If the client's submitted parameters need to map to the server-defined `struct` attributes, the default mapping relationship can be used, which is very convenient. The default conversion rules are as follows:

1. Attributes in the `struct` that need matching must be **public attributes** (capitalized first letter).
2. Parameter names will automatically match with `struct` attributes in a **case-insensitive** manner and **ignore `-/ /space` symbols**.
3. If matching is successful, the key-value is assigned to the attribute; if not, the key-value is ignored.

Here are some matching examples:

```html
Map Key       Struct Attribute    Match
name          Name                match
Email         Email               match
nickname      NickName            match
NICKNAME      NickName            match
Nick-Name     NickName            match
nick_name     NickName            match
nick name     NickName            match
NickName      Nick_Name           match
Nick-name     Nick_Name           match
nick_name     Nick_Name           match
nick name     Nick_Name           match
```

Since object conversion at the underlying layer uses the `gconv` module, it also supports the `c/gconv/json` tags. More detailed rules can be found in the section [Type Conversion - Struct Conversion](../../核心组件/类型转换/类型转换-Struct转换.md).

### Custom Rules

Please use custom mapping rules in business scenarios where there is a significant difference between object properties and parameter names; otherwise, please use the default parameter mapping rules. A large number of custom rules tags can increase code maintenance costs.

Custom parameter mapping rules can be implemented by binding a `tag` to `struct` attributes. The tag name can be `p/param/params`. For example:

```go
type User struct{
    Id    int
    Name  string
    Pass1 string `p:"password1"`
    Pass2 string `p:"password2"`
}
```

In which we use the `p` tag to specify the parameter name bound to the attribute. The `password1` parameter will map to the `Pass1` attribute, and `password2` will map to the `Pass2` attribute. Other attributes use default conversion rules without needing to set a `tag`.

## `Parse` Conversion

We can also use the `Parse` method to achieve `struct` conversion. This method is a convenience method that will automatically perform conversion and data validation internally, but if the `struct` does not have a bound validation `tag`, the validation logic will not be executed.
:::warning
Starting from `GoFrame v2`, we recommend using a structured approach to define route methods for more convenient management of input and output data structures and instances. For details, please refer to: [Route Registration - Standard Routes](../路由管理/路由管理-路由注册/路由注册-规范路由/路由注册-规范路由.md)
:::
Usage example:

```go
package main

import (
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
)

type RegisterReq struct {
    Name  string
    Pass  string `p:"password1"`
    Pass2 string `p:"password2"`
}

type RegisterRes struct {
    Code  int         `json:"code"`
    Error string      `json:"error"`
    Data  interface{} `json:"data"`
}

func main() {
    s := g.Server()
    s.BindHandler("/register", func(r *ghttp.Request) {
        var req *RegisterReq
        if err := r.Parse(&req); err != nil {
            r.Response.WriteJsonExit(RegisterRes{
                Code:  1,
                Error: err.Error(),
            })
        }
        // ...
        r.Response.WriteJsonExit(RegisterRes{
            Data: req,
        })
    })
    s.SetPort(8199)
    s.Run()
}
```

In this example, we define two structs: `RegisterReq` for parameter reception and `RegisterRes` for data return.

We use `r.Parse(&req)` to convert the client-submitted parameters to a `RegisterReq` object. When the conversion is successful, the `req` variable will be initialized and assigned (default is `nil`); otherwise, the method returns an `err` and the `req` variable is `nil`. The return data structure is defined using `RegisterRes`, and the return format is `JSON`, implemented via `r.Response.WriteJsonExit`. This method converts `RegisterRes` to `JSON` format based on the `json` tags defined internally and exits the current service method without executing subsequent logic.

To demonstrate the test result, the `Data` attribute of the normal return result returns the `RegisterReq` object. Since this object does not have a bound `json` tag, the returned `JSON` field will have its attribute names.

After execution, we test it using the `curl` tool:

```bash
$ curl "http://127.0.0.1:8199/register?name=john&password1=123&password2=456"
{"code":0,"error":"","data":{"Name":"john","Pass":"123","Pass2":"456"}}

$ curl -d "name=john&password1=123&password2=456" -X POST "http://127.0.0.1:8199/register"
{"code":0,"error":"","data":{"Name":"john","Pass":"123","Pass2":"456"}}
```

We used both `GET` and `POST` submission methods for testing. You can see that the server perfectly receives the submitted parameters and completes the object conversion.