---
slug: '/docs/web/request-struct-converting'
title: 'Request Input - Object Handling'
sidebar_position: 1
hide_title: true
keywords: [object conversion, parameter mapping, GoFrame framework, request parsing, struct conversion, custom mapping, data validation, route registration, JSON return, Go language]
description: "This document provides a detailed introduction on how to handle object conversion for request inputs when using the GoFrame framework. By defining inputs and outputs as struct objects, it facilitates structured parameter maintenance. The document introduces default and custom parameter mapping rules, and how to easily perform object conversion and data validation through the Parse method of the Request object."
---

## Object Conversion

Object conversion is very common in request processing. We recommend defining inputs and outputs as `struct` objects to facilitate structured parameter input and output maintenance. The `GoFrame` framework supports very convenient object conversion, allowing client-submitted parameters such as `Query` parameters, form parameters, content parameters, `JSON/XML`, and more, to be easily converted into specified `struct` objects, while also maintaining the mapping relationship between submitted parameters and `struct` properties.

The object conversion method uses the `Parse` method of the `Request` object or the `Get*Struct` methods. For specific method definitions, please refer to the API documentation: [https://pkg.go.dev/github.com/gogf/gf/v2/net/ghttp#Request](https://pkg.go.dev/github.com/gogf/gf/v2/net/ghttp#Request)

## Parameter Mapping

### Default Rules

When client-submitted parameters need to be mapped to server-defined `struct` properties, default mapping relationships can be used. This is very convenient. The default conversion rules are as follows:

1. Properties to be matched in the `struct` must be **public properties** (first letter capitalized).
2. Parameter names will automatically match `struct` properties in a **case-insensitive** manner and **ignore `-/_/space` symbols**.
3. If a match is successful, assign the key-value to the property; if not, ignore that key-value.

Here are some matching examples:

```html
map key name      struct property     match status
name              Name                match
Email             Email               match
nickname          NickName            match
NICKNAME          NickName            match
Nick-Name         NickName            match
nick_name         NickName            match
nick name         NickName            match
NickName          Nick_Name           match
Nick-name         Nick_Name           match
nick_name         Nick_Name           match
nick name         Nick_Name           match
```

Since the underlying object conversion uses the `gconv` module, it also supports `c/gconv/json` tags. For more detailed rules, refer to the [Type Conversion - Struct Conversion](../../core-components/type-conversion/type-conversion-struct-conversion.md) section.

### Custom Rules

Please use custom mapping rules in business scenarios where there is a significant difference between object property names and parameter names, otherwise use the default parameter mapping rules as the use of a large number of custom rule tags can increase maintenance costs.

Custom parameter mapping rules can be implemented by binding a `tag` to the `struct` properties. The `tag` name can be `p/param/params`. For example:

```go
type User struct{
    Id    int
    Name  string
    Pass1 string `p:"password1"`
    Pass2 string `p:"password2"`
}
```

We use the `p` tag to specify the parameter name the property is bound to. The `password1` parameter will map to the `Pass1` property, and `password2` will map to the `Pass2` property. Other properties use the default conversion rules without needing a `tag`.

## `Parse` Conversion

We can also use the `Parse` method to perform `struct` conversion. This method is a convenient method that internally performs conversion and data validation. If there is no validation `tag` bound in the `struct`, the validation logic will not be executed.
:::warning
Starting from `GoFrame v2`, we recommend using a structured way to define route methods to more conveniently manage input and output data structures and their instances. For more details, see: [Route Registration - Standardized Routes](../route-management/route-management-route-registration/route-registration-standardized-route/route-registration-standardized-route.md)
:::
Usage example:

```go
package main

import (
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
)

type RegisterReq struct {
    Name  string
    Pass  string `p:"password1"`
    Pass2 string `p:"password2"`
}

type RegisterRes struct {
    Code  int         `json:"code"`
    Error string      `json:"error"`
    Data  interface{} `json:"data"`
}

func main() {
    s := g.Server()
    s.BindHandler("/register", func(r *ghttp.Request) {
        var req *RegisterReq
        if err := r.Parse(&req); err != nil {
            r.Response.WriteJsonExit(RegisterRes{
                Code:  1,
                Error: err.Error(),
            })
        }
        // ...
        r.Response.WriteJsonExit(RegisterRes{
            Data: req,
        })
    })
    s.SetPort(8199)
    s.Run()
}
```

In this example, we define two structs: `RegisterReq` for parameter reception and `RegisterRes` for data return.

Here, using `r.Parse(&req)` converts the client-submitted parameters into a `RegisterReq` object. When the conversion is successful, the `req` variable will be initialized with a value (default is `nil`); otherwise, the method returns an `err` and the `req` variable is `nil`. The data return structure is defined by `RegisterRes`, and the return format is `JSON`, achieved through `r.Response.WriteJsonExit`. This method converts `RegisterRes` to `JSON` format according to its internal defined `json` tags and exits the current server method, not executing the subsequent logic of the method.

To demonstrate the test effect, the `RegisterReq` object is returned in the `Data` property of the normal return result. Since the object does not have a `json` tag bound, the returned `JSON` field will be its property name.

After execution, we test with the `curl` tool:

```bash
$ curl "http://127.0.0.1:8199/register?name=john&password1=123&password2=456"
{"code":0,"error":"","data":{"Name":"john","Pass":"123","Pass2":"456"}}

$ curl -d "name=john&password1=123&password2=456" -X POST "http://127.0.0.1:8199/register"
{"code":0,"error":"","data":{"Name":"john","Pass":"123","Pass2":"456"}}
```

We used both `GET` and `POST` submission methods for testing. You can see that the server can perfectly obtain the submitted parameters and complete the object conversion.